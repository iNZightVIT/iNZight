.onAttach <- function(libname, pkgname) {
    lwd <- getOption("width")
    ind <- paste(rep(" ", floor(0.05 * lwd)), collapse = "")
    header <- paste(rep("=", lwd), collapse = "")
    parwrap <- function(txt, indent = "")
        paste(strwrap(txt, prefix = ind), collapse = "\n")

    ## Ensure we're using RGtk2
    options("guiToolkit" = "RGtk2")

    packageStartupMessage(header)
    packageStartupMessage("")
    packageStartupMessage(parwrap("You have successfully loaded the iNZight package!"))
    packageStartupMessage("")
    packageStartupMessage(parwrap("To get started with iNZight simply run the following command:"))
    packageStartupMessage("")
    packageStartupMessage(parwrap("iNZight()"))
    packageStartupMessage("")
    packageStartupMessage(header)

    ## try to load extension packages
    #for (lib in c("iNZightModules", "iNZightTS", "iNZightMR")) {
    #    if (lib %in% installed.packages())
    #        eval(parse(text = paste0("require(", lib, ", quietly = TRUE)")))
    #}
}



iNZSaveFile <- function(theFile, ext, ...) {
    ###################################
    ### generic function to save an object
    ## theFile: file name to be saved, possible with path
    ## ext: the desired extension of the file
    ## which: from which device to save (only for plots)
    ## data: data.frame to save (only for datasets)
    ##       one of which/data needs to be present
    ## ... further arguments like fileType to distinguish
    ##     between different .txt files
    ###################################
    args = list(...)
    if (is.null(args$which) && is.null(args$data))
        return(list(msg = "What to save not specified"))
    ## device number 1 is null device (empty)
    if (!is.null(args$which) && args$which == 1)
        return(list(msg = "There is no plot to save"))
    ## Determine whether a user has specified a file just by name
    ## rather than using the file browser
    dirsep <- if (.Platform$OS.type == "windows") "[\\]" else "/"
    ## In the case that a user has given a filename rather than
    ## a file path, set the save location to the current working dir
    if (length(strsplit(theFile, dirsep)[[1]]) == 1)
        theFile <- paste(getwd(), theFile, sep = .Platform$file.sep)
    tmp <- unlist(strsplit(basename(theFile), split="\\.")) # split on dots
    ext.tmp <- tmp[length(tmp)] # take the string after last dot
    if (length(ext) == 0)
        list(msg = "Invalid extension")
    else if (ext.tmp != ext)
        ## if the specified ext is not attached to thefile, attach it
        theFile <- paste(theFile, ext, sep = ".")

    ## change the class of theFile and then use S3 to get correct fn
    class(theFile) <- ext
    .iNZSaveFile(theFile, ext, ...)
}

.iNZSaveFile <- function(theFile, ext, ...)
    UseMethod('.iNZSaveFile')
## create a function for every file extension
.iNZSaveFile.default <- function(theFile, ext, ...) {
    ## do some default behaviour
}

.iNZSaveFile.pdf <- function(theFile, ext, ...) {
    which <- list(...)$which
    curDev <- dev.cur()
    dev.set(which)
    dev.copy2pdf(file = theFile)
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.png <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(png, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.bmp <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(bmp, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.tiff <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(tiff, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.jpg <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(jpeg, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.jpeg <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(jpeg, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.csv <- function(theFile, ext, ...) {
    data <- list(...)$data
    write.csv(data, file = theFile, row.names = FALSE)
    TRUE
}

.iNZSaveFile.txt <- function(theFile, ext, ...) {
    data <- list(...)$data
    filetype <- list(...)$fileType
    if (filetype == 4)
        sep = " "
    else
        sep = "\t"
    write.table(data, file = theFile, sep = sep, row.names = FALSE)
    TRUE
}

.iNZSaveFile.rda <- function(theFile, ext, data, dataname, ...) {
    assign(dataname, data)
    save(list = dataname, file = theFile)
    TRUE
}


####################################
## modifyList is defined again here
## because R 3.0.1 does not support the
## keep.null argument. R 3.0.2 does, so
## this can be deleted once the R version
## of the release is updated accordingly
####################################
modifyList <- function (x, val, keep.null = FALSE)
{
    stopifnot(is.list(x), is.list(val))
    xnames <- names(x)
    vnames <- names(val)
    vnames <- vnames[vnames != ""]
    if (keep.null) {
        for (v in vnames) {
            x[v] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]]))
                list(modifyList(x[[v]], val[[v]], keep.null = keep.null))
            else val[v]
        }
    }
    else {
        for (v in vnames) {
            x[[v]] <- if (v %in% xnames && is.list(x[[v]]) &&
                is.list(val[[v]]))
                modifyList(x[[v]], val[[v]], keep.null = keep.null)
            else val[[v]]
        }
    }
    x
}

`%notin%` <- function(x, table) !(x %in% table)

## THIS SHOULD HAPPEN IN INZIGHTPLOTS
construct_call <- function(settings, model,
                           data = quote(.dataset),
                           design = quote(!!.design),
                           what = c("plot", "summary", "inference")) {
    if (is.null(settings$x)) return(NULL)

    what <- match.arg(what)

    ## remove names:
    rem_names <- c("pch")
    for (n in rem_names) {
        names(settings[[n]]) <- NULL
    }

    ## remove options
    rmv_args <- c("locate.settings")
    settings <- settings[names(settings) %notin% rmv_args]

    # go through settings and compare to default settings
    default_args <- formals(iNZightPlots::iNZightPlot)
    inz_args <- iNZightPlots::inzpar()
    if (what %in% c("summary", "inference")) {
        smry_args <- formals(iNZightPlots::getPlotSummary)
        smry_args <- smry_args[names(smry_args) %notin% names(default_args)]
        default_args <- c(default_args, smry_args)
    }
    defaults <- c(default_args, inz_args)
    lapply(names(settings), function(s_name) {
        is_same <- identical(
            settings[[s_name]],
            defaults[[s_name]],
            ignore.bytecode = TRUE,
            ignore.environment = TRUE
        )
        if (is_same) settings[[s_name]] <<- NULL
    })

    ## set the data
    settings$data <- data
    if (!is.null(model$dataDesign)) {
        settings$data <- NULL
        # .design <- model$createSurveyObject()
        settings$design <- design
    }

    ## order of list
    name_order <- c(names(default_args),  names(inz_args))
    name_order <- name_order[name_order %in% names(settings)]

    ## missing args
    missing <-
        names(settings) %notin% name_order &
        names(settings) %notin% c("data_name")
    if (any(missing)) {
        name_miss <- names(settings)[missing]
        name_order <- c(name_order, name_miss)
    }

    settings <- settings[name_order]

    # formula
    if (!is.null(settings$y) || !is.null(settings$g1) || !is.null(settings$g2)) {
        fmla <- as.character(settings$x)
        if (!is.null(settings$y)) {
            fmla <- paste(fmla, as.character((settings$y)), sep = " ~ ")
        } else {
            fmla <- paste(fmla, ".", sep = " ~ ")
        }
        if (!is.null(settings$g1) || !is.null(settings$g2)) {
            if (is.null(settings$g1)) {
                if (settings$g2.level == "_ALL") {
                    gfm <- NULL
                    settings$g2.level <- NULL
                } else {
                    gfm <- as.character(settings$g2)
                    settings$g1.level <- settings$g2.level
                    settings$g2.level <- NULL
                }
            } else if (is.null(settings$g2) || settings$g2.level == "_ALL") {
                gfm <- as.character(settings$g1)
            } else {
                gfm <- paste(
                    as.character(settings$g1),
                    as.character(settings$g2),
                    sep = " + "
                )
            }

            if (!is.null(gfm))
                fmla <- paste(fmla, "|", gfm)
        }
        if (grepl(" ~ \\.$", fmla)) {
            fmla <- settings$x
        } else {
            fmla <- eval(parse(text = fmla))
        }
        settings <- c(list(f = fmla), settings)
        settings$x <- NULL
        settings$y <- NULL
        settings$g1 <- NULL
        settings$g2 <- NULL
    }

    ## plot.features
    if (!is.null(settings$plot.features)) {
        settings$plot.features <- modifyList(list(), settings$plot.features)
        if (length(settings$plot.features) == 0)
            settings$plot.features <- NULL
    }

    ## transformations
    if (!is.null(settings$transform)) {
        settings$transform <- modifyList(list(), settings$transform)
        if (length(settings$transform) == 0)
            settings$transform <- NULL
    }

    # only include overwritten varnames
    # vnames <- settings$varnames
    # for (vn in names(vnames)) {
    #     if (is.null(settings[[vn]]) ||
    #         is.null(vnames[[vn]]) ||
    #         settings[[vn]] == vnames[[vn]])
    #         vnames[[vn]] <- NULL
    # }
    # settings$varnames <- if (length(vnames)) vnames else NULL
    settings$varnames <- NULL

    ## remove names:
    rem_names <- c("pch")
    for (n in rem_names) {
        names(settings[[n]]) <- NULL
    }

    ## g1.level/g2.level
    if (isTRUE(settings$g1.level == "_MULTI")) settings$g1.level <- NULL
    if (isTRUE(settings$g2.level == "_ALL")) settings$g2.level <- NULL

    if (what == "plot") {
        ## things unique to plots


        ## Locator:
        #### if nothing being located, no need to pass "order.first" setting
        # if (is.null(settings$locate) || is.null(settings$locate.id) ||
        #     length(settings$locate.id) == 0 ||
        #     highlight
        ## actually I think this will do ...
        # if (!is.null(settings$plot.features$order.first) &&
        #     is.null(settings$locate) &&
        #     is.null(settings$locate.id) &&
        #     is.null(settings$hightlight)) {

        #     plopt <- settings$plot.features
        #     plopt$order.first <- NULL
        #     plopt <- modifyList(list(), plopt)
        #     if (length(plopt) == 0) plopt <- NULL
        #     settings$plot.features <- plopt
        # }

    } else {
        ## things unique to summary/inference


        if (what == "summary") {
            ## things unique to summary

        }
        if (what == "inference") {
            ## things unique to inference

        }
    }

    ## remove any NULLs
    settings <- modifyList(list(), settings)
    settings <- lapply(settings,
        function(x)
            if (is.null(x) || (is.character(x) && all(x == "NULL"))) NULL else x
    )

    ## drop "x = " and "y = "
    names(settings) <- ifelse(names(settings) %in% c("f", "x", "y"),
        paste0(names(settings), "DROP"),
        names(settings)
    )

    call <- capture.output(dput(settings))
    fn <- switch(what,
        plot = "iNZPlot",
        summary = "iNZSummary",
        inference = "iNZInference"
    )
    call <- gsub("^list", fn, call)
    call <- gsub(".DROP = ", "", call)

    parse(text = paste(call, collapse = "\n"))
}

# a very roundabout way to get the code correct ...
mend_call <- function(call, gui) {
    # adjust name
    dname <- attr(gui$getActiveData(), "name", exact = TRUE)
    if (is.null(dname) || dname == "")
        dname <- sprintf("data%s",
            ifelse(activeDoc == 1, "", activeDoc)
        )
    dname <- iNZightTools::create_varname(dname)
    code <- as.character(call)
    code <- gsub(".dataset", dname, code, fixed = TRUE)
    if (!is.null(call[[1]]$design)) {
        code <- gsub("!!.design", ".design", code, fixed = TRUE)
        code <- gsub(".design", gui$getActiveDoc()$getModel()$dataDesignName,
            code,
            fixed = TRUE
        )
    }
    code
}
